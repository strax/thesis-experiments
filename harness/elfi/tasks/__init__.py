from __future__ import absolute_import, annotations

from functools import wraps
from typing import (
    Dict,
    NamedTuple,
    Protocol,
    Tuple,
    TypeAlias,
    runtime_checkable,
)

import jax
import jax.numpy as jnp
import numpy as np
from elfi import Discrepancy, ElfiModel, GPyRegression
from numpy.random import RandomState
from jaxtyping import Array, ArrayLike

from harness.constraints import Constraint

Bounds: TypeAlias = Dict[str, Tuple[float, ...]]


class ELFIModelBuilder(Protocol):
    def build_model(self) -> ModelAndDiscrepancy: ...


class ELFIInferenceProblem(ELFIModelBuilder):
    @property
    def name(self): ...

    @property
    def bounds(self) -> Bounds:
        raise NotImplementedError

    @property
    def constraint(self): ...


@runtime_checkable
class SupportsBuildTargetModel(Protocol):
    def build_target_model(self, model: ElfiModel) -> GPyRegression: ...


class ModelAndDiscrepancy(NamedTuple):
    model: ElfiModel
    discrepancy: Discrepancy


class SimulatorFunction(Protocol):
    def __call__(
        self,
        *args: ArrayLike,
        batch_size: int,
        random_state: RandomState,
    ) -> ArrayLike: ...


def with_constraint(
    sim: SimulatorFunction, constraint: Constraint
) -> SimulatorFunction:
    def constrain(key: Array, theta: ArrayLike, simulated: ArrayLike) -> Array:
        feasible = jax.random.bernoulli(key, constraint(theta))
        # NOTE: We assume that observations generated by the simulator cannot
        #       independently fail: either the whole simulation fails or succeeds.
        return jnp.where(feasible, simulated, jnp.nan)

    @jax.jit
    def batched_constrain(key: Array, theta: ArrayLike, simulated: ArrayLike) -> Array:
        batch_size = jnp.size(theta, 0)
        keys = jax.random.split(key, batch_size)
        return jax.vmap(constrain)(keys, theta, simulated)

    @wraps(sim)
    def constrained_sim(*args: ArrayLike, batch_size: int, random_state: RandomState):
        theta = np.stack(args, axis=-1)
        assert (
            np.size(theta, 0) == batch_size
        ), "batch_size does not match input dimensions"

        simulated = sim(*args, batch_size=batch_size, random_state=random_state)
        assert (
            np.size(simulated, 0) == batch_size
        ), "batch_size does not match output dimensions"

        simulated = batched_constrain(
            jax.random.key(random_state.tomaxint()), theta, simulated
        )
        return np.asarray(simulated)

    return constrained_sim
